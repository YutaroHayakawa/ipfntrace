#include <linux/skbuff.h>
#include <uapi/linux/ip.h>
#include <uapi/linux/tcp.h>
#include <uapi/linux/udp.h>
#include <uapi/linux/ipv6.h>
#include <uapi/linux/ptrace.h>

/*
 * Bowrrowed the idea from tracepkt
 * https://github.com/yadutaf/tracepkt
 */
#define member_read(_dst, _src, _member)                 \
  do{                                                    \
    bpf_probe_read(                                      \
      _dst,                                              \
      sizeof(_src->_member),                             \
      ((char*)_src) + offsetof(typeof(*_src), _member)   \
    );                                                   \
  } while(0)

struct event_data {
  uint64_t tstamp;
  uint64_t faddr;
  uint8_t protocol;
  uint16_t l3_protocol;
  union {
    struct {
      uint32_t saddr;
      uint32_t daddr;
    } v4;
    struct {
      uint8_t saddr[16];
      uint8_t daddr[16];
    } v6;
  };
  uint16_t sport;
  uint16_t dport;
  uint8_t data[64];
};

#if L3_PROTO == 0x0008
static inline bool
ipv4_match(uint8_t **head, struct event_data *e)
{
  bool ret = true;
  struct iphdr iph;

  bpf_probe_read(&iph, sizeof(iph), *head);

  e->v4.saddr = iph.saddr;
#ifndef SADDRV4_ANY
  if (e->v4.saddr != SADDRV4) ret = false;
#endif

  e->v4.daddr = iph.daddr;
#ifndef DADDRV4_ANY
  if (e->v4.daddr != DADDRV4) ret = false;
#endif

  /*
   * Skip the options
   */
  *head = *head + (iph.ihl * 4);

  e->protocol = iph.protocol;

  return ret;
}
#endif

#if L3_PROTO == 0xdd86
static inline bool
ipv6_match(uint8_t **head, struct event_data *e)
{
  struct ipv6hdr iph;

  bpf_probe_read(&iph, sizeof(iph), *head);

  memcpy(e->v6.saddr, &iph.saddr, 16);
#ifndef SADDRV6_ANY
  uint8_t saddr[16] = { SADDRV6 };
  #pragma unroll
  for (int i = 0; i < 16; i++)
    if (e->v6.saddr[i] != saddr[i]) return false;
#endif

  memcpy(e->v6.daddr, &iph.daddr, 16);
#ifndef DADDRV6_ANY
  uint8_t daddr[16] = { DADDRV6 };
  #pragma unroll
  for (int i = 0; i < 16; i++)
    if (e->v6.daddr[i] != daddr[i]) return false;
#endif

  /*
   * Skip the extension headers.
   * Due to the limitation of the BPF we only can handle
   * limited number of headers (we chose 8 in here for now).
   */
  uint8_t nexthdr = iph.nexthdr;
  uint8_t nexthdr_len = sizeof(iph);

  #pragma unroll
  for (int i = 0; i < 8; i++) {
    if (nexthdr == 0 || nexthdr == 41 ||
        nexthdr == 43 || nexthdr == 44) {
      *head += nexthdr_len;
      bpf_probe_read(&nexthdr, 1, *head);
      bpf_probe_read(&nexthdr_len, 1, *head + 1);
    } else {
      break;
    }
  }

  e->protocol = nexthdr;

  return true;
}
#endif

static inline bool
ip_match(uint8_t **head, struct event_data *e)
{
  bool matched;

  if (e->l3_protocol != L3_PROTO) {
    return false;
  }

#if L3_PROTO == 0x0008
  matched = ipv4_match(head, e);
#elif L3_PROTO == 0xdd86
  matched = ipv6_match(head, e);
#else
  #error Unknown IP version
#endif

  return matched;
}

static inline bool
tcp_match(uint8_t **head, struct event_data *e)
{
  struct tcphdr tcph;

  bpf_probe_read(&tcph, sizeof(tcph), *head);

  e->sport = tcph.source;
#ifndef SPORT_ANY
  if (e->sport != SPORT) return false;
#endif

  e->dport = tcph.dest;
#ifndef DPORT_ANY
  if (e->dport != DPORT) return false;
#endif

  return true;
}

static inline bool
udp_match(uint8_t **head, struct event_data *e)
{
  struct udphdr udph;

  bpf_probe_read(&udph, sizeof(udph), *head);

  e->sport = udph.source;
#ifndef SPORT_ANY
  if (e->sport != SPORT) return false;
#endif

  e->dport = udph.dest;
#ifndef DPORT_ANY
  if (e->dport != DPORT) return false;
#endif

  return true;
}

static inline bool
transport_match(uint8_t **head, struct event_data *e)
{
  bool matched = true;

#ifndef PROTO_ANY
  if (e->protocol != PROTO) {
    return false;
  }
#endif

  /* 
   * We will match to the inner most header for tunneling protocols
   * so, ignore the L3 protocol `matched` flag for them.
   */
  switch (e->protocol) {
    case 6: /* TCP */
      matched = tcp_match(head, e);
      break;
    case 17: /* UDP */
      matched = udp_match(head, e);
      break;
    default:
      break;
  }

  return matched;
}

static inline bool
match(struct pt_regs *ctx, struct sk_buff *skb, struct event_data *e)
{
  bool matched;
  uint8_t *head;
  uint16_t ipofs;

  member_read(&head, skb, head);
  member_read(&ipofs, skb, network_header);
  member_read(&e->l3_protocol, skb, protocol);

  head += ipofs;

  if (!ip_match(&head, e)) {
    return false;
  }

  if (!transport_match(&head, e)) {
    return false;
  }

  return true;
}

BPF_PERF_OUTPUT(events);

static inline void
output(struct pt_regs *ctx, struct event_data *e)
{
  events.perf_submit(ctx, e, sizeof(*e));
}

/*
 * Declare the prototype of the custom match function in here.
 * The function will be generated by main Python program and
 * put on the bottom of this file.
 */
static inline bool custom_match(void*, struct sk_buff*, uint8_t*);

/*
 * Reduce the number of attached BPF programs.
 *
 * The position of the skb should be 1,2,3 or 4 due to the
 * limitation of the eBPF program. This allow us to attach
 * sufficient tracing function depends on the skb position
 * instead of generating it for each kernel functions.
 */

#define IPFTRACE_MAIN_BODY \
  struct event_data e = { \
    bpf_ktime_get_ns(), \
    PT_REGS_IP(ctx) \
  }; \
  if (!match(ctx, skb, &e)) { \
    return; \
  } \
  if (!custom_match(ctx, skb, e.data)) { \
    return; \
  } \
  output(ctx, &e);

void ipftrace_main1(struct pt_regs *ctx, struct sk_buff *skb)
{
  IPFTRACE_MAIN_BODY
}

void ipftrace_main2(struct pt_regs *ctx, uint64_t dummy1, struct sk_buff *skb)
{
  IPFTRACE_MAIN_BODY
}

void ipftrace_main3(struct pt_regs *ctx, uint64_t dummy1, uint64_t dummy2,
                    struct sk_buff *skb)
{
  IPFTRACE_MAIN_BODY
}

void ipftrace_main4(struct pt_regs *ctx, uint64_t dummy1, uint64_t dummy2,
                    uint64_t dummy3, struct sk_buff *skb)
{
  IPFTRACE_MAIN_BODY
}
